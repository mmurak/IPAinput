<html>
    <head>
        <title>Stroke Data Collector</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
        <style>
            canvas {
                outline: black 1px solid;
            }
            #candidatesArea {
                font-size: 200%;
            }
            #candidatesArea a{
                color: black;
                text-decoration: none;
                font-size: 120%;
            }
            #candidatesArea a:hover{
                color: red;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" width="300" height="300"></canvas>
        <br/>
        <input type="button" id="rollbackButton" disabled value="Rollback" onclick="rollbackStroke();">
        <input type="button" id="clearButton" value="Clear" onclick="clearCanvas();">
        <br/>
        <p id="candidatesArea"></p>

        <script src="./minimal.js"></script>
        <script src="./TinyRecogniser.js"></script>
        <script>
        class GlobalManager {
            constructor() {
                this.selArea = document.getElementById("candidatesArea");
                this.rollbackButton = document.getElementById("rollbackButton");
                this.canvas = document.getElementById("canvas");
                this.ctx = this.canvas.getContext("2d");
                this.ctx.lineWidth = 0.5;
                this.w = this.canvas.width;
                this.h = this.canvas.height;
                this.halfW = Math.floor(this.w / 2);
                this.halfH = Math.floor(this.h / 2);
                this.imageArray = [];
                this.isDrag = false;
                this.lastX = null;
                this.lastY = null;
                this.strokePath = [];
                this.aggregatedArea = [];
                this.engine = new TinyRecogniser(minimalDict);
            }
        }
        let G = new GlobalManager();
        G.canvas.addEventListener("mousedown", (evt) => { dragStart(evt); });
        G.canvas.addEventListener("mouseup", (evt) => { dragEnd(evt); });
        G.canvas.addEventListener("mouseout", (evt) => { dragEnd(evt); });
        G.canvas.addEventListener("mousemove", (evt) => { draw(fixedX(evt), fixedY(evt)); });
        G.canvas.addEventListener("touchstart", (evt) => { touchStart(evt); });
        G.canvas.addEventListener("touchend", (evt) => { touchEnd(evt); });
        G.canvas.addEventListener("touchmove", (evt) => { touchMove(evt); });
        clearCanvas();

        function dragStart(evt) {
            G.imageArray.push(G.ctx.getImageData(0, 0, G.w, G.h));
            G.rollbackButton.disabled = false;
            G.ctx.beginPath();
            G.isDrag = true;
            G.strokePath = [];
            G.strokePath.push(whichQuadrant(fixedX(evt), fixedY(evt)));
            draw(fixedX(evt), fixedY(evt));
        }
        function dragEnd(evt) {
            if (!G.isDrag)  return;
            G.ctx.closePath();
            G.isDrag = false;
            G.lastX = null;
            G.lastY = null;
            G.aggregatedArea.push(regulariseStroke(G.strokePath.join("") + ":"));
            let candidates = G.engine.getCandidates(G.aggregatedArea.join(""));
            candidates.pop();
            displayCandidates(candidates);
        }

        function touchStart(evt) {
            evt.preventDefault();
            G.imageArray.push(G.ctx.getImageData(0, 0, G.w, G.h));
            G.rollbackButton.disabled = false;
            G.ctx.beginPath();
            G.isDrag = true;
            G.strokePath = [];
            G.strokePath.push(whichQuadrant(fixedX(evt), fixedY(evt)));
            draw(fixedX(evt), fixedY(evt));
        }
        function touchEnd(evt) {
            G.ctx.closePath();
            G.isDrag = false;
            G.lastX = null;
            G.lastY = null;
            G.aggregatedArea.push(regulariseStroke(G.strokePath.join("") + ":"));
            let candidates = G.engine.getCandidates(G.aggregatedArea.join(""));
            candidates.pop();
            displayCandidates(candidates);
        }
        function touchMove(evt) {
            let x = evt.changedTouches[0].pageX;
            let y = evt.changedTouches[0].pageY;
            draw(x, y);
        }

        function fixedX(evt) {
            return evt.clientX - G.canvas.getBoundingClientRect().left;
        }
        function fixedY(evt) {
            return evt.clientY - G.canvas.getBoundingClientRect().top;
        }
        function draw(x, y) {
            if (!G.isDrag) return;
                G.ctx.lineCap = "round";
                G.ctx.lineJoin = "round";
                G.ctx.strokeStyle = "blue";
                G.ctx.lineWidth = 7;
                if (G.lastX == null || G.lastY == null) {
                    G.ctx.moveTo(x, y);
                } else {
                    G.ctx.moveTo(G.lastX, G.lastY);
                }
                G.ctx.lineTo(x, y);
                G.ctx.stroke();
                G.lastX = x;
                G.lastY = y;
                let quad = whichQuadrant(x, y);
                if (quad != G.strokePath[G.strokePath.length - 1]) {
                    G.strokePath.push(quad);
                }
        }

        function whichQuadrant(x, y) {
            if (x > G.halfW) {
                if (y <= G.halfH) {
                    return "A";
                } else {
                    return "D";
                }
            } else {
                if (y <= G.halfH) {
                    return "B";
                } else {
                    return "C";
                }
            }
        }

        function regulariseStroke(str) {
            return str;
        }

        function selected(dat) {
            console.log(dat);
            G.selArea.innerHTML = "";
            clearCanvas();
        }

        function displayCandidates(canList) {
            let selections = "";
            canList.forEach(function(elem) {
                selections += 'ãƒ»<a href="javascript:selected(\'' + elem + '\');">' + elem + '</a><br/>';
            });
            G.selArea.innerHTML = selections;
//            console.log(selections);
        }

        function register() {
            G.storage.value += JSON.stringify(G.aggregatedArea) + ", ";
            clearPaths();
            cselector.nextColour();
        }

        // chores
        function drawCrossHairs() {
            G.ctx.beginPath();
            G.ctx.strokeStyle = "black";
            G.ctx.lineWidth = 0.5;
            G.ctx.setLineDash([2, 2]);
            G.ctx.moveTo(0, G.halfH);
            G.ctx.lineTo(G.w, G.halfH);
            G.ctx.moveTo(G.halfW, 0);
            G.ctx.lineTo(G.halfW, G.h);
            G.ctx.stroke();
            G.ctx.setLineDash([]);
        }
        function clearPaths() {
            G.strokePath = [];
            G.aggregatedArea = [];
        }
        function clearCanvas() {
            G.ctx.clearRect(0, 0, G.w, G.h);
            drawCrossHairs();
            clearPaths();
        }
        function rollbackStroke() {
            if (G.imageArray.length > 0) {
                let image = G.imageArray.pop();
                G.ctx.putImageData(image, 0, 0);
                G.aggregatedArea.pop();
                let candidates = G.engine.getCandidates(G.aggregatedArea.join(""));
                candidates.pop();
                if (G.imageArray.length <= 0) {
                    G.rollbackButton.disabled = true;
                }
                displayCandidates(candidates);
            }
        }
        </script>
    </body>
</html>
